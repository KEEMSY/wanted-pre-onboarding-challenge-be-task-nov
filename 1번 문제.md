# 1. 동시에 같은 `DB Table row` 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

가장 먼저 현재 애플리케이션의 구조가 `분산`아키텍처인지 `모놀리틱` 아키텍처인지에 따라 다르게 나눠질 것 같습니다.

<br>

>모놀리틱 아키텍처일 경우

`모놀리틱` 아키텍처일 경우, 해당 애플리케이션의 개발단계가 초기이거나, 혹은 큰 성능요구사항과 부하가 없을 것이라고 추측이 됩니다. 이 경우에는 코드레벨에서 동시성을 제어하는 `synchronized` 와 같은 동기 키워드를 활용하여 동시성 제어를 할 것 같습니다.

하지만 `synchronized` 의 경우 성능의 저하가 분명하고, 실제로 성능이슈가 문제가 된다면 데이터베이스를 통해 동시성을 제어하는 방법 중 하나인, `낙관적 락킹(Optimistic Locking)` 전략 혹은 `비관적 락킹(Pessimistic Locking)` 을 활용하여 동시성 제어를 할 것 입니다.

`낙관적 락킹` 은 데이터베이스 에서 접근 제어를 하지 않고, Update 시 `version` 을 확인하여 동시성을 제어하는 방법입니다. 이 방법은 코드레벨에서 `synchronized` 혹은 `비관적 락킹(Pessimistic Locking)` 전략에 비해 성능상의 이점이 존재합니다. 

하지만 지금 문제 상황과 같이 동시에 데이터를 업데이트 하는 경우라면,` 비관적 락킹`을 활용하는 것이 좋습니다.  데이터에 관해 동시성 제어가 빈번히 발생하는 경우, `낙관적 락킹`을 사용한다면 데이터 업데이트 실패(Version 불일치)로 인한 오버헤드가 발생할 수 있기 때문입니다. 그리고, `비관적 락킹`은 데이터 자체에 락을 걸어 동시성을 제어하기 때문에 낙관적 락킹 시 발생하는 버전의 충돌로 인한 오버헤드를 없앨 수 있습니다.

<br>

> 분산 아키텍처일 경우

`분산` 아키텍처일 경우, 모놀리틱 아키텍처에서 활용할 수 있는 `synchronized` 를 사용할 수 없습니다. `synchronized` 를 활용하여 단일 애플리케이션 내 스레드간의 동시성 제어는 가능하나, 서버단위의 동시성 제어는 해결할 수 없기 때문입니다. 따라서 분산 아키텍처라면 `낙관적 락킹` 혹은 `비관적 락킹` 그리고 외부 서비스인 `레디스`를 활용해서 동시성을 제어할 것 같습니다.

앞서 이야기한 것과 마찬가지로, `낙관적 락킹`과 `비관적 락킹` 전략은 데이터베이스 자체에서 관리하는 락킹 전략으로서 분산환경에서도 동시성 문제를 해결할 수 있습니다. 하지만 엄청난 수의 요청이 발생한다면, 이는 성능적인 요구사항을 충족시키지 못할 수 있습니다.

만약 데이터베이스 락킹전략을 활용하는데 있어서 성능 이슈가 고려됟다면, 중간 계층으로 `레디스`를 활용할 것 같습니다. `레디스`는 단일 스레드 기반의 인메모리 데이터베이스로 작업의 순서를 보장하면서 매우 빠른 처리속도를 보장하기 때문입니다. 하지만 인메모리 데이터베이스 특성상, 데이터 영구 저장을 위한 추가적인 작업이 필요하다는 것이 단점이 될 수 있습니다.

<br><br>

따라서 저는 데이터베이스 테이블의 데이터를 업데이트 간 발생하는 동시성 제어를 위해 가장먼저, 현재 애플리케이션의 아키텍처의 모습이 어떠한지에 대한 분석 이 후, 보다 알맞은 선택을 할 것입니다.

이에 대한 구체적인 방법으로는 코드레벨에서 동시성을 제어할 수 있는 `synchronized`, 데이터베이스의 락킹전략인 `낙관적`, `비관적` 락킹 전략, 혹은 데이터베이스 아키텍처 구조를 활용한 `레디스`를 활용하여 데이터베이스에서 발생하는 동시성을 제어할 것 입니다.
